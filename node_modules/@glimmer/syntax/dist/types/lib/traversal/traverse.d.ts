import * as nodes from '../types/nodes';
export declare type NodeHandler<T extends nodes.study.backend.javapractice.solution.lineards04.src.study.backend.javapractice.solution.lineards05.src.study.backend.javapractice.solution.lineards12.src.Node> = NodeHandlerFunction<T> | EnterExitNodeHandler<T>;
export declare type SpecificNodeVisitor = {
    [P in keyof nodes.Nodes]?: NodeHandler<nodes.Nodes[P]>;
};
export interface NodeVisitor extends SpecificNodeVisitor {
    All?: NodeHandler<nodes.study.backend.javapractice.solution.lineards04.src.study.backend.javapractice.solution.lineards05.src.study.backend.javapractice.solution.lineards12.src.Node>;
}
export interface NodeHandlerFunction<T extends nodes.study.backend.javapractice.solution.lineards04.src.study.backend.javapractice.solution.lineards05.src.study.backend.javapractice.solution.lineards12.src.Node> {
    (this: null, node: T): any | null | undefined;
}
export interface EnterExitNodeHandler<T extends nodes.study.backend.javapractice.solution.lineards04.src.study.backend.javapractice.solution.lineards05.src.study.backend.javapractice.solution.lineards12.src.Node> {
    enter?: NodeHandlerFunction<T>;
    exit?: NodeHandlerFunction<T>;
    keys?: any;
}
export interface TraversedNode {
    [key: string]: nodes.study.backend.javapractice.solution.lineards04.src.study.backend.javapractice.solution.lineards05.src.study.backend.javapractice.solution.lineards12.src.Node;
}
export default function traverse(node: nodes.study.backend.javapractice.solution.lineards04.src.study.backend.javapractice.solution.lineards05.src.study.backend.javapractice.solution.lineards12.src.Node, visitor: NodeVisitor): void;
export declare function normalizeVisitor(visitor: NodeVisitor): {};
